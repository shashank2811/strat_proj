[params]
stock_name = "BANKNIFTY"
input_date = 2019-01-01
entry_time = 09:18:59
squareoff_time = 15:19:59
otype=['CE','PE']
week_expiry = 1
tr_segment = 2
stoploss_target_combo = [[1.5,0.5], [2,0.5]]










; # def get_spot_data(entry_time):
; #     """
; #     Get spot data for a specific entry time.

; #     Parameters:
; #         entry_time (str): The entry time to filter spot data.

; #     Returns:
; #         DataFrame: Filtered spot data.
; #     """
; #     entry_spot_data = bnifty_df[bnifty_df['tr_time'] == entry_time]
; #     return entry_spot_data
; # def apply_exit_conditions(row):
; #     date = row['tr_date']
; #     otype = row['otype']
; #     target = row['target']
; #     stoploss = row['stoploss']
    
; #     matching_row = dff[
; #         (dff['tr_date'] == date) &
; #         (dff['tr_time'] > entry_time) &
; #         (dff['tr_time'] <= squareoff_time) &
; #         (dff['week_expiry'] == week_expiry) &
; #         (dff['otype'] == otype) &
; #         ((dff['tr_low'] <= target) | (dff['tr_high'] >= stoploss)) 
; #     ]
; #     matching_row = matching_row.sort_values('tr_close')
; #     columns_to_display = ['tr_date', 'tr_time','tr_open','tr_low','tr_high', 'otype','tr_close','week_expiry']
; #     print(matching_row[columns_to_display])
    
; #     exit_type = None
; #     exit_price = None
; #     exit_time = None
; #     spp = matching_row['tr_low'].iloc[0]
; #     sll = matching_row['tr_high'].iloc[0] 

; #     if spp <= target:
; #         exit_type = 'TARGET'
; #         exit_price = target
; #         exit_time = matching_row['tr_time'].iloc[0]
; #     elif sll >= stoploss:
; #         exit_type = 'STOPLOSS'
; #         exit_price = stoploss
; #         exit_time = matching_row['tr_time'].iloc[0]
; #     elif matching_row['tr_time'] == squareoff_time:
; #         exit_type = 'SQOFF'
; #         exit_price = matching_row['tr_close']
; #         exit_time = squareoff_time

; #     row['exit_type'] = exit_type
; #     row['exit_price'] = exit_price
; #     row['exit_time'] = exit_time
                
; #     return row
    
; # def  add_lotsize_column(lotsize_df,df2):
; #     lotsize_df.rename(columns={'Date': 'tr_date'}, inplace=True)
; #     filter_dates_list = df2['tr_date'].unique()
; #     lotsize_df = lotsize_df[lotsize_df['tr_date'].isin(filter_dates_list)]
; #     date_lotsize_mapping = dict(zip(lotsize_df['tr_date'], lotsize_df['Lot_Size']))
; #     df2['lotsize'] = df2['tr_date'].map(date_lotsize_mapping)    
; #     return df2
; # #Header Files
; # import pandas as pd
; # import configparser

; # # Function to get entry price based on provided conditions
; # def get_entry_price(row):
; #     entry_price = fnoieddf[
; #         (fnoieddf['tr_date'] == row['tr_date']) &
; #         (fnoieddf['tr_time'] == row['tr_time']) &
; #         (fnoieddf['week_expiry'] == week_expiry) &
; #         (fnoieddf['otype'] == row['otype']) &
; #         (fnoieddf['strike_price'] == row['strike_price'])
; #     ]
; #     return entry_price['tr_close'].values[0] if not entry_price.empty else None

; # # Function to apply exit conditions and calculate exit parameters
; # def apply_exit_conditions(row):
; #     stoploss_target_sqoff_filter = (
; #         fnoieddf[
; #              (fnoieddf['tr_date'] == row['tr_date']) &
; #             (fnoieddf['tr_time'] > entry_time) & 
; #             (fnoieddf['tr_time'] <= squareoff_time) &
; #             (fnoieddf['week_expiry'] == week_expiry) &
; #             (fnoieddf['strike_price'] == row['strike_price']) &
; #             (fnoieddf['otype'] == row['otype']) &
; #             ((fnoieddf['tr_low'] <= row['target']) | (fnoieddf['tr_high'] >= row['stoploss']))
; #         ]
; #     )  
; #     if not stoploss_target_sqoff_filter.empty:
; #         matching_row_row =stoploss_target_sqoff_filter.iloc[0]  # Take the first matching row
        
; #         exit_type = None
; #         exit_price = None
; #         exit_time = None

; #         if matching_row_row['tr_time'] > entry_time:
; #             if matching_row_row['tr_low'] <= row['target']:
; #                 exit_type = 'TARGET'
; #                 exit_price = row['target']
; #                 exit_time = matching_row_row['tr_time']
; #             elif matching_row_row['tr_high'] >= row['stoploss']:
; #                 exit_type = 'STOPLOSS'
; #                 exit_price = row['stoploss']
; #                 exit_time = matching_row_row['tr_time']
; #         if matching_row_row['tr_time'] == squareoff_time:
; #             exit_type = 'SQOFF'
; #             exit_price = matching_row_row['tr_close']
; #             exit_time = squareoff_time

; #     return exit_type, exit_price, exit_time

; # # Function to prepare bankNifty DataFrame
; # def prepare_bankNifty(bnifty_df, entry_time):
; #     bankNifty = pd.concat([bnifty_df[bnifty_df['tr_time'] == entry_time]] * 2, ignore_index=True)
; #     bankNifty = bankNifty.assign(
; #         otype=(['CE', 'PE'] * (len(bankNifty) // 2 + 1))[:len(bankNifty)],
; #         strike_price=((bankNifty['tr_close'] // 100) * 100)
; #     )
; #     bankNifty['entry_price'] = bankNifty.apply(get_entry_price, axis=1)
; #     return bankNifty

; # # Function to calculate target and stoploss columns
; # def calculate_target_stoploss(df):
; #     df = df.assign(
; #         target=df['entry_price'] * 0.5,
; #         stoploss=df['entry_price'] * 1.5
; #     )
; #     return df

; # # Function to add lot size column to DataFrame
; # def add_lotsize_column(lotsize_df,df):
; #     filter_dates_list = df['tr_date'].unique()
; #     lotsize_df = lotsize_df[lotsize_df['tr_date'].isin(filter_dates_list)]
; #     date_lotsize_mapping = dict(zip(lotsize_df['tr_date'], lotsize_df['Lot_Size']))
; #     df['lotsize'] = df['tr_date'].map(date_lotsize_mapping)    
; #     return df

; # def main():
; #     bnifty_df['tr_time'] = bnifty_df['tr_time'].astype(str)
; #     fnoieddf['tr_time'] = fnoieddf['tr_time'].astype(str)
; #     fnoieddf['tr_date'] = pd.to_datetime(fnoieddf['tr_date']).dt.strftime('%d-%m-%Y')
; #     lotsize_df.rename(columns={'Date': 'tr_date'}, inplace=True)
; #     lotsize_df['tr_date'] = pd.to_datetime(lotsize_df['tr_date']).dt.strftime('%d-%m-%Y')
; #     lotsize_df.rename(columns={'BankNifty': 'Lot_Size'}, inplace=True)

; #     # Step 1 and 2: Prepare bankNifty DataFrame
; #     bankNiftydf = prepare_bankNifty(bnifty_df, entry_time)

; #     # Step 3: Calculate target and stoploss columns
; #     bankNiftydf = calculate_target_stoploss(bankNiftydf)

; #     # Step 4: Apply exit conditions
; #     bankNiftydf = bankNiftydf.apply(apply_exit_conditions, axis=1)
; #     print(bankNiftydf)
; #     # Step 5: Add lot size column and prepare final DataFrame
; #     bankNiftydf = add_lotsize_column(lotsize_df, bankNiftydf)
; #     columns_to_drop = ['tr_open', 'tr_high', 'tr_low', 'week_expiry_date', 'expiry_date', 'tr_segment']
; #     bankNiftydf = bankNiftydf.drop(columns=columns_to_drop, errors='ignore')

; #     # Save final DataFrame to CSV
; #     output_csv_path = 'BankNifty.csv'
; #     bankNiftydf.to_csv(output_csv_path, index=False)

; # if __name__ == '__main__':
; #     config = configparser.ConfigParser()
; #     config.read('config.ini')
; #     #reading data from config files
; #     entry_time = str(config.get('params', 'entry_time'))
; #     week_expiry = int(config.get('params', 'week_expiry'))
; #     squareoff_time = str(config.get('params', 'squareoff_time'))
; #     #Reading csv and excel files
; #     bnifty_df = pd.read_csv('spot_data.csv')
; #     excel_file_path = 'FNO_DATA.xlsx'
; #     fnoieddf = pd.read_excel(excel_file_path)
; #     lotsize_df = pd.read_csv('LotSize_Data.csv')
; #     main()









































; matching_row['tr_time'] == squareoff_time
; # date = row['tr_date']
;     # otype = row['otype']
;     # target = row['target']
;     # stoploss = row['stoploss']
    
;     # matching_rows = dff[
;     #     (dff['tr_date'] == date) &
;     #     (dff['tr_time'] <= squareoff_time) &
;     #     (dff['week_expiry'] == week_expiry) &
;     #     (dff['tr_time'] > entry_time)&(dff['tr_close']>=200)&
;     #     (dff['otype'] == otype)&((dff['tr_low'] <= target) | (dff['tr_high'] >= stoploss))
;     # ]
;     # print(matching_rows)
    
;     # if not matching_rows.empty:
;     #     matching_row_row = matching_rows.sort_values('tr_close').iloc[0]  # Take the first matching row    
;     #     print(matching_row_row)
;     #     exit_type = None
;     #     exit_price = None
;     #     exit_time = None

;     #     if matching_row_row['tr_time'] > entry_time:
;     #         if matching_row_row['tr_low'] <= target:
;     #             exit_type = 'TARGET'
;     #             exit_price = target
;     #             exit_time = matching_row_row['tr_time']
;     #         elif matching_row_row['tr_high'] >= stoploss:
;     #             exit_type = 'STOPLOSS'
;     #             exit_price = stoploss
;     #             exit_time = matching_row_row['tr_time']
;     #     if matching_row_row['tr_time'] == squareoff_time:
;     #         exit_type = 'SQOFF'
;     #         exit_price = matching_row_row['tr_close']
;     #         exit_time = squareoff_time

;     #     row['exit_type'] = exit_type
;     #     row['exit_price'] = exit_price
;     #     row['exit_time'] = exit_time
                
;     # return row